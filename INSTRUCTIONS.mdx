# Relation Many To Many

### ğŸ’¡ Comprendre les relations Many To Many

## ğŸ“ Tes notes

Detaille ce que tu as appris ici,Â surÂ uneÂ pageÂ [Notion](https://go.mikecodeur.com/course-notes-template)

## Comprendre

Rappel :

Relation **N-N** (Many-to-Many)

- **Description** : Un enregistrement dans la table A peut Ãªtre associÃ© Ã  plusieurs enregistrements dans la table B, et vice versa.
- **Exemple** : Les Ã©tudiants (`students`) et les cours (`courses`). Un Ã©tudiant peut suivre plusieurs cours, et un cours peut Ãªtre suivi par plusieurs Ã©tudiants.
- **ImplÃ©mentation** : CrÃ©ation d'une table de jonction (ou d'association) avec deux clÃ©s Ã©trangÃ¨res, une pointant vers la table A et l'autre vers la table B.

Exemple en SQL

```sql
CREATE TABLE students (
    id SERIAL PRIMARY KEY,
    name VARCHAR(255) NOT NULL,
    email VARCHAR(255) UNIQUE NOT NULL,
    enrollment_date DATE NOT NULL
);

CREATE TABLE courses (
    id SERIAL PRIMARY KEY,
    course_name VARCHAR(255) NOT NULL,
    course_code VARCHAR(100) UNIQUE NOT NULL,
    credits INT NOT NULL
);
```

Table de jonction

```sql
CREATE TABLE student_courses (
    student_id INT NOT NULL,
    course_id INT NOT NULL,
    PRIMARY KEY (student_id, course_id),
    FOREIGN KEY (student_id) REFERENCES students(id) ON DELETE CASCADE,
    FOREIGN KEY (course_id) REFERENCES courses(id) ON DELETE CASCADE
);
// NOTE : La PK est une composition des 2 FK
```

De cette maniÃ¨re on peut dire :

- 1 `Student` possÃ¨de N `Course`
- 1 `Course` Appartient Ã  N `studient`

**Avec Drizzle**

```tsx

export const students = pgTable("students", {
    id: serial("id").primaryKey(),
    name: varchar("name", { length: 255 }).notNull(),
    email: varchar("email", { length: 255 }).notNull().unique(),
    enrollment_date: date("enrollment_date").notNull(),
});

export const courses = pgTable("courses", {
    id: serial("id").primaryKey(),
    course_name: varchar("course_name", { length: 255 }).notNull(),
    course_code: varchar("course_code", { length: 100 }).notNull().unique(),
    credits: integer("credits").notNull(),
});

export const studentCourses = pgTable("student_courses", {
    student_id: integer("student_id").notNull().references(() => students.id),
    course_id: integer("course_id").notNull().references(() => courses.id),
},
(table) => ({
    pk: primaryKey(table.student_id, table.course_id)
}));

// RELATION
export const studentCoursesRelations = relations(studentCourses, ({ one }) => ({
  student: one(students, {
    fields: [studentCourses.student_id],
    references: [students.id],
  }),
  course: one(courses, {
    fields: [studentCourses.course_id],
    references: [courses.id],
  }),
}));
// Optionnel : Relations inversÃ©es pour `students` et `courses`
export const studentsRelations = relations(students, ({ many }) => ({
  courses: many(studentCourses, {
    fields: [studentCourses.student_id],
    references: [students.id],
  }),
}));

export const coursesRelations = relations(courses, ({ many }) => ({
  students: many(studentCourses, {
    fields: [studentCourses.course_id],
    references: [courses.id],
  }),
}));
```

ğŸ“‘ Le liens vers la doc [https://orm.drizzle.team/docs/rqb#many-to-many](https://orm.drizzle.team/docs/rqb#many-to-many)

Des frameworks JavaScript modernes ont donc Ã©tÃ© crÃ©Ã©s pour relever certains des dÃ©fis en crÃ©ant par programme le DOM plutÃ´t que de le dÃ©finir Ã  la main HTML.

## Exercice

Dans cet exercice nous allons modÃ©liser des groupes utilisateurs tel que

- 1 `Utilisateur` peut avoir plusieurs `Groupes`
- 1 `Groupe` peut avoir plusieurs `Utilisateur`

Il sâ€™agit dâ€™un relation `many` to `many`

**ğŸ¶ Dans un premier temps tu vas devoir modÃ©liser les groupes dans `users`**

- fichier `src/db/schema/users`

Tu vas devoir crÃ©er

- la table `groups`
- la table de relation `users_to_groups` avec comme PK le combinaison de 2 FK

ğŸ“‘ Doc composite PK [https://orm.drizzle.team/docs/indexes-constraints#composite-primary-key](https://orm.drizzle.team/docs/indexes-constraints#composite-primary-key)

- la relation `groupsRelations` (many)
- la relation `usersToGroupsRelations` (one)

**ğŸ¶ Dans un second temps tu vas devoir faire les `Queries`**

- `getUsersWithGroups` : Les users avec leurs groupes
- `getGroupsWithUsers` : Les groupes avec leurs users

Fichiers

- `src/db/schema/users`
- `exercises/many-many/actions`

## Bonus

### 1. ğŸš€ getGroupsWithUsersFilter

- **ğŸ¶ Dans cet exercice tu vas devoir filtrer par nom de groupe**

Fait une recherche et rÃ©cupÃ¨re le groupe en fonction de son nom

```tsx
export async function getGroupsWithUsersFilter(groupName: string) {
...

where: (groups, {eq}) => eq(groups.name, groupName),
```

Utilise `with` de plusieurs niveau pour pouvoir avoir tous les autres groupes des `users` de ce groupe

```tsx
with: {
      usersToGroups: { ...
```

Fichiers

- `exercises/many-many/actions`

### 2. ğŸš€ Relation inverse direct

Manipuler la table de jonction peut etre plus compliquer et moins claire dans le code. Par exemple on utilise `user?.usersToGroups` pour rÃ©cupÃ©rer les groupes dans un cas

```tsx
//recuperation des groupes
{user?.usersToGroups?.map((usersToGroup, index) => (
  <Badge key={index} variant="secondary">
      {usersToGroup.group.name}
  </Badge>
))}
```

Et pour rÃ©cupÃ©rer les user : `group?.usersToGroups`

```tsx
{group?.usersToGroups?.map((usersToGroup, index) => (
      <Badge key={index} variant="secondary">
        {usersToGroup.user.name}
      </Badge>
    ))}
```

Pour simplifier cela il suffit de spÃ©cifier la relation inverse exemple `usersRelations`

```tsx
// ajout de
// groups: many(usersToGroups),
export const usersRelations = relations(users, ({one, many}) => ({
  profileInfo: one(profileInfo, {
    fields: [users.id],
    references: [profileInfo.userId],
  }),
  usersToGroups: many(usersToGroups),
  groups: many(usersToGroups),
}))

// ajout de
// users: many(usersToGroups),
export const groupsRelations = relations(groups, ({many}) => ({
  usersToGroups: many(usersToGroups),
  users: many(usersToGroups),
}))
```

Les requetes sont maintenant simplifiÃ©es

```tsx
const resultQuery = await db.query.users.findMany({
    with: {
      usersToGroups: {
        with: {
          group: true,
        },
      },
    },
  })
```

```tsx
const resultQuery = await db.query.users.findMany({
    with: {
      groups: true,
  })
```

Fichiers

- `exercises/many-many/actions`

## Aller plus loin

ğŸ“‘ Le lien vers la doc [https://orm.drizzle.team/docs/rqb#many-to-many](https://orm.drizzle.team/docs/rqb#many-to-many)

## Ils vont tâ€™aider

- **ğŸ¶ Mowgli le Chien** : _Mowgli te guidera dans chaque exercice._
- **ğŸ¤– Ash le Robot** : _Ash le Robot te donnera du code utile._
- **ğŸš€ Julia La roquette** : _Julia te donnera des dÃ©fis supplÃ©mentaires._
- **â›ï¸ Hulk le Marteau** : _Quand du code Ã  supprimer est prÃ©sent_
- **ğŸ‘¨â€âœˆï¸ Hugo le chef de projet** : _Va t'aider sur les spÃ©cifications du projet_

## ğŸœ Feedback

Remplir le formulaire le [formulaire de FeedBack](https://go.mikecodeur.com/cours-next-avis?entry.1912869708=Next%20PRO&entry.1430994900=Data%20Modeling&entry.533578441=08%20Many%20To%20Many).
