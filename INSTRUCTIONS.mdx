# Relation One To Many

### ğŸ’¡ Description longue de l'exercice

## ğŸ“ Tes notes

Detaille ce que tu as appris ici,Â surÂ uneÂ pageÂ [Notion](https://go.mikecodeur.com/course-notes-template)

## Comprendre

Les relations 1-N (One to Many) sont le le type de relation le plus rÃ©pandu. Ces par exemple

- 1 Panier â€”> contient N produits
- 1 User â€”> possÃ¨de N posts

Dans lâ€™autre sens

- 1 Produit â€”> appartient Ã  1 Panier
- 1 Postâ€”> appartient Ã  1 User

Pour dÃ©finir ce type de relation avec `Drizzle` il faut dÃ©finir la relation dans les deux sens. Exemple

```tsx

export const users = pgTable('users', {
  id: serial('id').primaryKey(),
  name: text('name'),
});

export const posts = pgTable('posts', {
  id: serial('id').primaryKey(),
  content: text('content'),
  authorId: integer('author_id'),
});

// avec 'one'
// 1 Post appartients Ã  un user ('one')
export const postsRelations = relations(posts, ({ one }) => ({
  author: one(users, {
    fields: [posts.authorId],
    references: [users.id],
  }),
}));
// avec 'many'
// 1 User possÃ¨de plusieurs posts ('many')
export const usersRelations = relations(users, ({ many }) => ({
  posts: many(posts),
}));
```

Il est ensuite possible de rÃ©cupÃ©rer â€œautomatiquementâ€ les relations liÃ©s avec `with` : exemple

```tsx
const result = await db.query.users.findFirst({
  with: {
    posts: true
  },
});
// va retourner le premier utilisateur trouvÃ© avec tout ses posts associÃ©s
// output result :
[{
  id: 1,
  name: "Dan",
  posts: [
    {
      id: 1,
      content: "SQL is awesome",
      authorId: 1,
    },
    {
      id: 2,
      content: "But check relational queries",
      authorId: 1,
    }
  ]
}]
```

## Exercice

Dans cet exercice nous avons repris nos `Products` et `Categories` et nous les avons ajoutÃ© a `Drizzle`

```tsx
// src/db/schema/...
export const categories = pgTable('category', {
  id: serial('id').primaryKey(),
  name: text('name'),
})

export const products = pgTable('product', {
  id: serial('id').primaryKey(),
  title: varchar('title', {length: 256}),
  price: real('price'),
  description: text('description'),
  image: varchar('image', {length: 256}),
  category: integer('category_id'),
  quantity: integer('quantity'),
  createdAt: date('createdat'),
  updatedAt: date('updatedat'),
})
```

```tsx
// src/db/schema/index.ts

const db = drizzle(pool, {
  schema: {...todos, ...users, ...categories, ...products},
})
```

**ğŸ¶ 1. CrÃ©er la relation `1 to many` dans les shemas**

**ğŸ¶ 2. Adapte la requÃªte `getCategoriesByIdWithProducts`**

Constate pour que chaque catÃ©gorie nous avons bien plusieurs produits

Fichiers

- `src/db/products`
- `src/db/categories`
- `exercises/one-many/actions`

## Bonus

### 1. ğŸš€ Imbrication

Dans chaque catÃ©gorie nous avons les produits. Le champs `product.category` contient lâ€™id de la catÃ©gorie. Or Ã  lâ€™Ã©cran nous voulons le nom et nom lâ€™id. Nous voulons donc charger Ã©galement la relation.

**ğŸ¶ Dans cet utilise `with` Ã  lâ€™intÃ©rieur du premier `with` pour rÃ©cupÃ©rer les noms de catÃ©gories**

```tsx
with: {
    products: {
      with: ... //imbrication
    },
  },
```

Fichiers

- `exercises/one-many/actions`

###

## Aller plus loin

ğŸ“‘ Le lien vers la doc [https://www.w3schools.com/html/html_css.asp](https://www.w3schools.com/html/html_css.asp)

## Ils vont tâ€™aider

- **ğŸ¶ Mowgli le Chien** : _Mowgli te guidera dans chaque exercice._
- **ğŸ¤– Ash le Robot** : _Ash le Robot te donnera du code utile._
- **ğŸš€ Julia La roquette** : _Julia te donnera des dÃ©fis supplÃ©mentaires._
- **â›ï¸ Hulk le Marteau** : _Quand du code Ã  supprimer est prÃ©sent_
- **ğŸ‘¨â€âœˆï¸ Hugo le chef de projet** : _Va t'aider sur les spÃ©cifications du projet_

## ğŸœ Feedback

Remplir le formulaire le [formulaire de FeedBack](https://go.mikecodeur.com/cours-next-avis?entry.1912869708=Next%20PRO&entry.1430994900=Data%20Modeling&entry.533578441=07%20One%20to%20many).
