# Transactions

### üí° Comprendre les transactions

## üìù Tes notes

Detaille ce que tu as appris ici,¬†sur¬†une¬†page¬†[Notion](https://go.mikecodeur.com/course-notes-template)

## Comprendre

Dans une application, il arrive fr√©quemment que certaines fonctionnalit√©s soit un ensemble d‚Äôop√©rations. Prenons par exemple un achat en ligne. Les op√©rations pourrait √™tre :

1. **V√©rification du stock** : V√©rifier que le produit command√© est bien en stock.
2. **D√©bit du compte client** : D√©biter le montant de l'achat sur le compte du client.
3. **Mise √† jour du stock** : R√©duire la quantit√© en stock du produit achet√©.
4. **Cr√©ation de la commande** : Enregistrer la commande dans la base de donn√©es.

Que se passe-t-il si un probl√®me survient √† l‚Äô√©tape 3 ?

- On s‚Äôarr√™te et affiche un message d‚Äôerreur ?

Oui mais l‚Äôop√©ration l‚Äô√©tape 2 **D√©bit du compte client,** √† d√©j√† √©t√© ex√©cut√©

- Comment faire ? G√©rer cela fonctionnellement

```tsx
async function processOrder() {
  try {
    // 1. V√©rification du stock
    const stock = await checkStock(productId);
    if (stock <= 0) {
      throw new Error("Produit en rupture de stock");
    }

    // 2. D√©bit du compte client
    const debitSuccess = await debitAccount(accountId, amount);
    if (!debitSuccess) {
      throw new Error("√âchec du d√©bit du compte client");
    }

    // 3. Mise √† jour du stock
    const updateStockSuccess = await updateStock(productId);
    if (!updateStockSuccess) {
      // Probl√®me √† l'√©tape 3, on recr√©dite le compte
      await creditAccount(accountId, amount);
      throw new Error("√âchec de la mise √† jour du stock. Compte recr√©dit√©.");
    }

    // 4. Cr√©ation de la commande
    const orderCreated = await createOrder(orderId, productId, accountId, amount);
    if (!orderCreated) {
      // Probl√®me √† l'√©tape 4, on recr√©dite le compte et on remet le stock
      await creditAccount(accountId, amount);
      await restoreStock(productId);
      throw new Error("√âchec de la cr√©ation de la commande. Compte recr√©dit√© et stock restaur√©.");
    }

    console.log("Commande trait√©e avec succ√®s");

  } catch (error) {
    console.error("Erreur lors du traitement de la commande:", error.message);
  }
}
```

Cela peut vite poser des probl√®mes et notre base de donn√©es peut se retrouver dans un √©tat incoh√©rent.

Les bases de donn√©es relationnel nous permettent de g√©rer des `Transactions`

### Transactions

Le transactionnel en SQL est un concept fondamental qui permet de regrouper plusieurs op√©rations de base de donn√©es en une seule unit√© de travail, appel√©e transaction.

Une transaction garantit que toutes les op√©rations s'ex√©cutent de mani√®re atomique, c'est-√†-dire qu'elles r√©ussissent toutes ou sont toutes annul√©es en cas d'√©chec, assurant ainsi l'int√©grit√© des donn√©es.

Ce m√©canisme est particuli√®rement crucial dans les syst√®mes o√π les erreurs ou les interruptions peuvent compromettre la coh√©rence des donn√©es.

Les transactions suivent les propri√©t√©s ACID (Atomicit√©, Coh√©rence, Isolation, Durabilit√©), qui sont essentielles pour garantir la fiabilit√© des op√©rations en base de donn√©es.

### Transactions avec Drizzle

Les transactions s‚Äôutilise avec `db.transaction`

```tsx
await db.transaction(async (tx) => {
  await tx.update(accounts).set({ balance: sql`${accounts.balance} - 100.00` }).where(eq(users.name, 'Dan'));
  await tx.update(accounts).set({ balance: sql`${accounts.balance} + 100.00` }).where(eq(users.name, 'Andrew'));
});
```

Si une erreur survient sur une des op√©rations de la transaction, on `rollback`.

Il est √©galement possible de `rollback` dans le code. Exemple

```tsx
if (account.balance < 100) {
  // This throws an exception that rollbacks the transaction.
  tx.rollback()
}

// ou en levant un Error
if (account.balance < 100) {
   // This throws an exception that rollbacks the transaction.
	 throw new Error(`Insufficient funds in ${accountUserId1}'s account`)
}

```

üìë Le liens vers la doc [https://orm.drizzle.team/docs/transactions](https://orm.drizzle.team/docs/transactions)

## Exercice

Dans cet exercice nous avons ajout√© une table pour les compte bancaire ‚Äò`accounts`‚Äô

```tsx
export const accounts = pgTable('accounts', {
  id: serial('id').primaryKey(),
  userId: integer('user_id')
    .references(() => users.id)
    .notNull(),
  balance: numeric('balance', {precision: 10, scale: 2})
    .default(sql`0`)
    .notNull(),
  blocked: boolean('blocked').default(false),
})

```

Nous avons li√© `account` √† `user`

```tsx
export const accountRelations = relations(accounts, ({one}) => ({
  user: one(users, {
    fields: [accounts.userId],
    references: [users.id],
  }),
}))
```

Et nous avons la fonction `getAccountByUserId`

```tsx
export async function getAccountByUserId(userId: number) {
  const userAccounts = await db
    .select()
    .from(accounts)
    .where(eq(accounts.userId, userId))
  return userAccounts[0]
}
```

Et nous avons une fonction `transferFunds` qui est un ensemble de plusieurs op√©rations SQL

- `Select` Account 1
- `Select` Account 2
- `Update` Account 1 (d√©bit)
- `Update` Account 2 (cr√©dit)
- Un fonction qui g√©n√®re al√©atoirement un erreur

```tsx

export async function transferFunds(
  accountUserId1: number,
  accountUserId2: number,
  amount: number
) {
  try {
    // V√©rification du solde du compte source
    const [account1] = await db
      .select()
      .from(accounts)
      .where(eq(accounts.userId, accountUserId1))

    const [account2] = await db
      .select()
      .from(accounts)
      .where(eq(accounts.userId, accountUserId2))


    // D√©bit du compte source
    await db
      .update(accounts)
      .set({balance: sql`${accounts.balance} - ${amount}`})
      .where(eq(accounts.userId, accountUserId1))

    // Simulation d'une erreur al√©atoire pour illustrer l'absence de transaction
    if (Math.random() < 0.5) {
      throw new Error("Une erreur al√©atoire s'est produite apr√®s le d√©bit !")
    }

    // Cr√©dit du compte de destination (ce code peut ne pas √™tre atteint en cas d'erreur)
    await db
      .update(accounts)
      .set({balance: sql`${accounts.balance} + ${amount}`})
      .where(eq(accounts.userId, accountUserId2))

}
```

**Lorsque l‚Äôerreur est lev√©e, le compte est d√©bit√©, mais le compte receveur n‚Äôest pas cr√©dit√©**

- **üê∂ Adapte la fonction** `transferFunds` pour la rendre transactionnelle

Fichiers

- `exercises/transaction/action.tsx`

## Bonus

### 1. üöÄ Rollback & TransactionRollbackError

`Drizzle` nous permet de faire un `rollback` avec `tx.rollback()`. (au lieu de lev√© un error). Ce n‚Äôest pas la meilleures des mani√®re mais nous allons voir comment faire. Il suffit de remplacer :

```tsx
if (!account1 || Number(account1.balance) < amount) {
   throw new Error(`Insufficient funds in ${accountUserId1}'s account`)
}
```

par

```tsx
if (!account1 || Number(account1.balance) < amount) {
   tx.rollback()
}
// L√®ve une erreur
// MAIS ne permet pas d'indiquer la cause
```

Mais nous pouvons distinguer le type d‚Äôerreur dans le `catch` pour rendre le message moins g√©n√©rique car

```tsx
catch (error: unknown) {
  if (error instanceof Error) {
    console.error(`Transaction failed: ${error.message}`)
  } else {
    console.error('Transaction failed: Unknown error')
  }
  throw error
}
// car seulement afficher le message 'rollback'
```

Nous voulons distinguer les cas suivant

- `Error` g√©n√©rique inconnue
- `Error` de type `Error`
- `Error` Drizzle type `DrizzleError` (par exemple erreur SQL, contraintes ou autres)
- `Error` de transaction type `TransactionRollbackError` (par exemple un rolback)

**üê∂ impl√©mente cela**

```tsx
if (error instanceof TransactionRollbackError) {
      console.error(`Transaction failed: ${error.message}`)
      throw new Error('Transaction failed: Rollback')
    }
    if (error instanceof DrizzleError) {
      console.error(`Transaction failed: ${error.message}`)
      throw new Error('BDD error : Rollback')
    }
    if (error instanceof Error) {
      console.error(`Transaction failed: ${error.message}`)
    } else {
      console.error('Transaction failed: Unknown error')
    }
    throw error
  }
```

Fichiers

- `exercises/transaction/action.tsx`

###

## Aller plus loin

üìë Le lien vers la doc [https://www.w3schools.com/html/html_css.asp](https://www.w3schools.com/html/html_css.asp)

## Ils vont t‚Äôaider

- **üê∂ Mowgli le Chien** : _Mowgli te guidera dans chaque exercice._
- **ü§ñ Ash le Robot** : _Ash le Robot te donnera du code utile._
- **üöÄ Julia La roquette** : _Julia te donnera des d√©fis suppl√©mentaires._
- **‚õèÔ∏è Hulk le Marteau** : _Quand du code √† supprimer est pr√©sent_
- **üë®‚Äç‚úàÔ∏è Hugo le chef de projet** : _Va t'aider sur les sp√©cifications du projet_

## üêú Feedback

Remplir le formulaire le [formulaire de FeedBack](https://go.mikecodeur.com/cours-next-avis?entry.1912869708=Next%20PRO&entry.1430994900=Data%20Modeling&entry.533578441=12%20Les%Transactions).
