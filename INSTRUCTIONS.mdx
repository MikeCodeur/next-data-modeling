# Relation Many To Many

### 💡 Comprendre les relations Many To Many

## 📝 Tes notes

Detaille ce que tu as appris ici, sur une page [Notion](https://go.mikecodeur.com/course-notes-template)

## Comprendre

Rappel :

Relation **N-N** (Many-to-Many)

- **Description** : Un enregistrement dans la table A peut être associé à plusieurs enregistrements dans la table B, et vice versa.
- **Exemple** : Les étudiants (`students`) et les cours (`courses`). Un étudiant peut suivre plusieurs cours, et un cours peut être suivi par plusieurs étudiants.
- **Implémentation** : Création d'une table de jonction (ou d'association) avec deux clés étrangères, une pointant vers la table A et l'autre vers la table B.

Exemple en SQL

```sql
CREATE TABLE students (
    id SERIAL PRIMARY KEY,
    name VARCHAR(255) NOT NULL,
    email VARCHAR(255) UNIQUE NOT NULL,
    enrollment_date DATE NOT NULL
);

CREATE TABLE courses (
    id SERIAL PRIMARY KEY,
    course_name VARCHAR(255) NOT NULL,
    course_code VARCHAR(100) UNIQUE NOT NULL,
    credits INT NOT NULL
);
```

Table de jonction

```sql
CREATE TABLE student_courses (
    student_id INT NOT NULL,
    course_id INT NOT NULL,
    PRIMARY KEY (student_id, course_id),
    FOREIGN KEY (student_id) REFERENCES students(id) ON DELETE CASCADE,
    FOREIGN KEY (course_id) REFERENCES courses(id) ON DELETE CASCADE
);
// NOTE : La PK est une composition des 2 FK
```

De cette manière on peut dire :

- 1 `Student` possède N `Course`
- 1 `Course` Appartient à N `studient`

**Avec Drizzle**

```tsx

export const students = pgTable("students", {
    id: serial("id").primaryKey(),
    name: varchar("name", { length: 255 }).notNull(),
    email: varchar("email", { length: 255 }).notNull().unique(),
    enrollment_date: date("enrollment_date").notNull(),
});

export const courses = pgTable("courses", {
    id: serial("id").primaryKey(),
    course_name: varchar("course_name", { length: 255 }).notNull(),
    course_code: varchar("course_code", { length: 100 }).notNull().unique(),
    credits: integer("credits").notNull(),
});

export const studentCourses = pgTable("student_courses", {
    student_id: integer("student_id").notNull().references(() => students.id),
    course_id: integer("course_id").notNull().references(() => courses.id),
},
(table) => ({
    pk: primaryKey(table.student_id, table.course_id)
}));

// RELATION
export const studentCoursesRelations = relations(studentCourses, ({ one }) => ({
  student: one(students, {
    fields: [studentCourses.student_id],
    references: [students.id],
  }),
  course: one(courses, {
    fields: [studentCourses.course_id],
    references: [courses.id],
  }),
}));
// Optionnel : Relations inversées pour `students` et `courses`
export const studentsRelations = relations(students, ({ many }) => ({
  courses: many(studentCourses, {
    fields: [studentCourses.student_id],
    references: [students.id],
  }),
}));

export const coursesRelations = relations(courses, ({ many }) => ({
  students: many(studentCourses, {
    fields: [studentCourses.course_id],
    references: [courses.id],
  }),
}));
```

📑 Le liens vers la doc [https://orm.drizzle.team/docs/rqb#many-to-many](https://orm.drizzle.team/docs/rqb#many-to-many)

Des frameworks JavaScript modernes ont donc été créés pour relever certains des défis en créant par programme le DOM plutôt que de le définir à la main HTML.

## Exercice

Dans cet exercice nous allons modéliser des groupes utilisateurs tel que

- 1 `Utilisateur` peut avoir plusieurs `Groupes`
- 1 `Groupe` peut avoir plusieurs `Utilisateur`

Il s’agit d’un relation `many` to `many`

**🐶 Dans un premier temps tu vas devoir modéliser les groupes dans `users`**

- fichier `src/db/schema/users`

Tu vas devoir créer

- la table `groups`
- la table de relation `users_to_groups` avec comme PK le combinaison de 2 FK

📑 Doc composite PK [https://orm.drizzle.team/docs/indexes-constraints#composite-primary-key](https://orm.drizzle.team/docs/indexes-constraints#composite-primary-key)

- la relation `groupsRelations` (many)
- la relation `usersToGroupsRelations` (one)

**🐶 Dans un second temps tu vas devoir faire les `Queries`**

- `getUsersWithGroups` : Les users avec leurs groupes
- `getGroupsWithUsers` : Les groupes avec leurs users

Fichiers

- `src/db/schema/users`
- `exercises/many-many/actions`

## Bonus

### 1. 🚀 getGroupsWithUsersFilter

- **🐶 Dans cet exercice tu vas devoir filtrer par nom de groupe**

Fait une recherche et récupère le groupe en fonction de son nom

```tsx
export async function getGroupsWithUsersFilter(groupName: string) {
...

where: (groups, {eq}) => eq(groups.name, groupName),
```

Utilise `with` de plusieurs niveau pour pouvoir avoir tous les autres groupes des `users` de ce groupe

```tsx
with: {
      usersToGroups: { ...
```

Fichiers

- `exercises/many-many/actions`

### 2. 🚀 Relation inverse direct

Manipuler la table de jonction peut etre plus compliquer et moins claire dans le code. Par exemple on utilise `user?.usersToGroups` pour récupérer les groupes dans un cas

```tsx
//recuperation des groupes
{user?.usersToGroups?.map((usersToGroup, index) => (
  <Badge key={index} variant="secondary">
      {usersToGroup.group.name}
  </Badge>
))}
```

Et pour récupérer les user : `group?.usersToGroups`

```tsx
{group?.usersToGroups?.map((usersToGroup, index) => (
      <Badge key={index} variant="secondary">
        {usersToGroup.user.name}
      </Badge>
    ))}
```

Pour simplifier cela il suffit de spécifier la relation inverse exemple `usersRelations`

```tsx
// ajout de
// groups: many(usersToGroups),
export const usersRelations = relations(users, ({one, many}) => ({
  profileInfo: one(profileInfo, {
    fields: [users.id],
    references: [profileInfo.userId],
  }),
  usersToGroups: many(usersToGroups),
  groups: many(usersToGroups),
}))

// ajout de
// users: many(usersToGroups),
export const groupsRelations = relations(groups, ({many}) => ({
  usersToGroups: many(usersToGroups),
  users: many(usersToGroups),
}))
```

Les requetes sont maintenant simplifiées

```tsx
const resultQuery = await db.query.users.findMany({
    with: {
      usersToGroups: {
        with: {
          group: true,
        },
      },
    },
  })
```

```tsx
const resultQuery = await db.query.users.findMany({
    with: {
      groups: true,
  })
```

Fichiers

- `exercises/many-many/actions`

## Aller plus loin

📑 Le lien vers la doc [https://orm.drizzle.team/docs/rqb#many-to-many](https://orm.drizzle.team/docs/rqb#many-to-many)

## Ils vont t’aider

- **🐶 Mowgli le Chien** : _Mowgli te guidera dans chaque exercice._
- **🤖 Ash le Robot** : _Ash le Robot te donnera du code utile._
- **🚀 Julia La roquette** : _Julia te donnera des défis supplémentaires._
- **⛏️ Hulk le Marteau** : _Quand du code à supprimer est présent_
- **👨‍✈️ Hugo le chef de projet** : _Va t'aider sur les spécifications du projet_

## 🐜 Feedback

Remplir le formulaire le [formulaire de FeedBack](https://go.mikecodeur.com/cours-next-avis?entry.1912869708=Next%20PRO&entry.1430994900=Data%20Modeling&entry.533578441=08%20Many%20To%20Many).
